.\" Automatically generated by Pandoc 1.19.2.4
.\"
.TH "" "" "2022-08-10" "PMDK - " "PMDK Programmer's Manual"
.hy
.\" SPDX-License-Identifier: BSD-3-Clause
.\" Copyright 2021-2022, Intel Corporation
.SH NAME
.PP
\f[B]pmemset_config_set_event_callback\f[]() \- set an event callback
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemset.h>
#define\ PMEMSET_EVENT_CONTEXT_SIZE\ (64)
struct\ pmemset_event_context\ {
\ \ \ \ enum\ pmemset_event\ type;
\ \ \ \ union\ {
\ \ \ \ \ \ \ \ char\ _data[PMEMSET_EVENT_CONTEXT_SIZE];
\ \ \ \ \ \ \ \ struct\ pmemset_event_copy\ copy;
\ \ \ \ \ \ \ \ struct\ pmemset_event_move\ move;
\ \ \ \ \ \ \ \ struct\ pmemset_event_set\ set;
\ \ \ \ \ \ \ \ struct\ pmemset_event_flush\ flush;
\ \ \ \ \ \ \ \ struct\ pmemset_event_persist\ persist;
\ \ \ \ \ \ \ \ struct\ pmemset_event_remove_range\ remove_range;
\ \ \ \ \ \ \ \ struct\ pmemset_event_part_remove\ part_remove;
\ \ \ \ \ \ \ \ struct\ pmemset_event_part_add\ part_add;
\ \ \ \ \ \ \ \ struct\ pmemset_event_sds_update\ sds_update;
\ \ \ \ \ \ \ \ struct\ pmemset_event_badblock\ badblock;
\ \ \ \ \ \ \ \ struct\ pmemset_event_badblocks_cleared\ badblocks_cleared;
\ \ \ \ }\ data;
};

typedef\ int\ pmemset_event_callback(struct\ pmemset\ *set,
\ \ \ \ \ \ \ \ struct\ pmemset_event_context\ *ctx,
\ \ \ \ \ \ \ \ void\ *arg);

void\ pmemset_config_set_event_callback(struct\ pmemset_config\ *cfg,
\ \ \ \ \ \ \ \ pmemset_event_callback\ *callback,\ void\ *arg);
\f[]
.fi
.SH DESCRIPTION
.PP
The \f[B]pmemset_config_set_event_callback\f[]() sets an user provided
\f[I]callback\f[] in \f[I]cfg\f[].
\f[I]arg\f[] will be passed to the \f[I]callback\f[] each time it will
be called by the library.
.PP
The callback will be called by \f[I]pmemset\f[] each time an event
occurs.
Events are only fired during the user\[aq]s calls of the
\f[B]libpmemset\f[](7) methods.
The detailed list of events and its description can be found in
\f[I]Events\f[] section below.
The \f[I]callback\f[] function should return 0 in case of success.
If the event supports error handling, the \f[I]callback\f[] can return a
non\-zero value in case of error, otherwise return value is ignored.
Struct \f[I]pmemset_event_context\f[] is a tagged union, which contains
all event structures, in \f[B]libpmemset\f[](7).
The \f[I]type\f[] field contains information of the type of the event
fired, where the data union contains event\-specific information.
.PP
There\[aq]s no guarantee that accessing pointers in \f[I]ctx\f[] inside
of the callback is thread\-safe.
The library user must guarantee this by not having multiple threads
accessing the same region on the set.
Once the function exits \f[I]ctx\f[] and its data are invalid.
.SH RETURN VALUE
.PP
The \f[B]pmemset_config_set_event_callback\f[]() returns no value.
.SH EVENTS
.IP
.nf
\f[C]
struct\ pmemset_event_flush\ {
\ \ \ \ void\ *addr;
\ \ \ \ size_t\ len;
};
\f[]
.fi
.PP
\f[B]PMEMSET_EVENT_FLUSH\f[] is fired before \f[B]pmemset_flush\f[](3)
or \f[B]pmemset_persist\f[](3) completes its work.
The \f[I]flush\f[] field in \f[I]data\f[] union contains \f[I]addr\f[]
and \f[I]len\f[] passed to those functions.
This event doesn\[aq]t support error handling, which means that the
value returned by the \f[I]callback\f[] function is ignored.
.PP
\f[B]PMEMSET_EVENT_DRAIN\f[] is fired after \f[B]pmemset_drain\f[](3) or
\f[B]pmemset_persist\f[](3) completes its work.
In case of \f[B]pmemset_persist\f[](3) this event is fired after
\f[B]PMEMSET_EVENT_FLUSH\f[].
This event doesn\[aq]t support error handling, which means that the
value returned by the \f[I]callback\f[] function is ignored.
.IP
.nf
\f[C]
struct\ pmemset_event_copy\ {
\ \ \ \ void\ *src;
\ \ \ \ void\ *dest;
\ \ \ \ size_t\ len;
\ \ \ \ unsigned\ flags;
};

struct\ pmemset_event_move\ {
\ \ \ \ void\ *src;
\ \ \ \ void\ *dest;
\ \ \ \ size_t\ len;
\ \ \ \ unsigned\ flags;
};

struct\ pmemset_event_set\ {
\ \ \ \ void\ *dest;
\ \ \ \ int\ value;
\ \ \ \ size_t\ len;
\ \ \ \ unsigned\ flags;
};
\f[]
.fi
.PP
\f[B]PMEMSET_EVENT_COPY\f[], \f[B]PMEMSET_EVENT_MOVE\f[],
\f[B]PMEMSET_EVENT_SET\f[] are fired, respectively, before
\f[B]pmemset_memcpy\f[](3), \f[B]pmemset_memmove\f[](3),
\f[B]pmemset_memset\f[](3) completed its work.
Similarly, \f[I]copy\f[], \f[I]move\f[], or \f[I]set\f[] fields in the
\f[I]data\f[] union contain all arguments passed to these functions.
If \f[B]PMEMSET_F_MEM_NODRAIN\f[] flag is \f[B]not\f[] passed to these
functions, a single \f[B]PMEMSET_EVENT_DRAIN\f[] will be fired on the
end of operation.
During these functions "flush" and "drain" operations are performed, but
they will not trigger any additional events.
\f[B]PMEMSET_EVENT_FLUSH\f[] and \f[B]PMEMSET_EVENT_DRAIN\f[] This event
doesn\[aq]t support error handling, which means that the value returned
by the \f[I]callback\f[] function is ignored.
.IP
.nf
\f[C]
struct\ pmemset_event_part_add\ {
\ \ \ \ void\ *addr;
\ \ \ \ size_t\ len;
\ \ \ \ struct\ pmem2_source\ *src;
};
\f[]
.fi
.PP
\f[B]PMEMSET_EVENT_PART_ADD\f[] is fired for each new part added to the
pmemset, after \f[B]pmemset_part_map\f[](3) completes its work.
The \f[I]part_add\f[] field in \f[I]data\f[] union contains address
\f[I]addr\f[] and length \f[I]len\f[] of the new part and a source
\f[I]src\f[] from which it was created.
.IP
.nf
\f[C]
struct\ pmemset_event_part_remove\ {
\ \ \ \ void\ *addr;
\ \ \ \ size_t\ len;
};
\f[]
.fi
.PP
\f[B]PMEMSET_EVENT_PART_REMOVE\f[] is fired for each part mapping
removed from the pmemset, before \f[B]pmemset_remove_part_map\f[](3)
function completes its work.
The \f[I]part_remove\f[] field in \f[I]data\f[] union contains
\f[I]addr\f[] and \f[I]len\f[] of the part to be removed.
.IP
.nf
\f[C]
struct\ pmemset_event_remove_range\ {
\ \ \ \ void\ *addr;
\ \ \ \ size_t\ len;
};
\f[]
.fi
.PP
\f[B]PMEMSET_EVENT_REMOVE_RANGE\f[] is fired for each range removed from
the pmemset, before \f[B]pmemset_remove_range\f[](3) function completes
its work.
The \f[I]remove_range\f[] field in \f[I]data\f[] union contains
\f[I]addr\f[] and \f[I]len\f[] of the range to be removed.
This event can trigger \f[B]PMEMSET_EVENT_PART_REMOVE\f[] for each whole
part mapping that is removed from the set as a result of the removed
range.
.IP
.nf
\f[C]
struct\ pmemset_event_sds_update\ {
\ \ \ \ struct\ pmemset_sds\ *sds;
\ \ \ \ struct\ pmemset_source\ *src;
};
\f[]
.fi
.PP
\f[B]PMEMSET_EVENT_SDS_UPDATE\f[] is fired after each change made to any
shutdown data state structure provided by the user.
Fields \f[I]sds\f[] and \f[I]src\f[] correspond respectively to the SDS
structure and a source it corresponds to.
.IP
.nf
\f[C]
struct\ pmemset_event_badblock\ {
\ \ \ \ struct\ pmemset_badblock\ *bb;
\ \ \ \ struct\ pmemset_source\ *src;
};
\f[]
.fi
.PP
\f[B]PMEMSET_EVENT_BADBLOCK\f[] is fired for each bad block detected in
the source \f[I]src\f[].
Bad block \f[I]bb\f[] contains \f[I]offset\f[] and \f[I]length\f[] of
the detected bad block.
.IP
.nf
\f[C]
struct\ pmemset_event_badblocks_cleared\ {
\ \ \ \ struct\ pmemset_source\ *src;
};
\f[]
.fi
.PP
\f[B]PMEMSET_EVENT_BADBLOCKS_CLEARED\f[] is fired when all bad blocks of
given source \f[I]src\f[] are cleared via event callback.
Bad blocks can be cleared with \f[B]pmemset_badblock_clear\f[](3)
function.
.SH SEE ALSO
.PP
\f[B]pmemset_badblock_clear\f[](3), \f[B]pmemset_map\f[](3),
\f[B]libpmem2\f[](7), \f[B]libpmemset\f[](7) and
\f[B]<http://pmem.io>\f[]
